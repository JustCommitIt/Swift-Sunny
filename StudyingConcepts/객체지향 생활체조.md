## 객체지향 생활체조

1. 한 메서드에 오직 한 단계의 들여쓰기만 합니다
2. else 표현을 사용하지 않습니다
3. 모든 원시 값과 문자열을 포장합니다
4. 한 줄에 점을 하나만 사용합니다
5. 이름을 줄여 쓰지 않습니다(축약 금지).
6. 모든 엔티티를 작게 유지합니다
7. 3개 이상의 스위프트 기본 데이터타입(Int, String, Double 등) 프로퍼티를 가진 타입을 구현하지 않습니다
8. 일급 콜렉션을 사용합니다
9. getter/setter를 구현하지 않습니다


### 객체지향 생활체조 추가 설명
- 하나의 함수는 하나의 일만 해야 한다.
    - 함수 네이밍 짓기에 편리하다.
    - 추후 변경 가능성이 용이해진다.
    - 함수는 7 ~ 10 줄 이내로 작성하는 것이 좋다.

- 매직 스트링, 하드코딩을 하지 말아야 한다.
    - nameSpace를 만들어 원시값과 문자열을 포장하는 것도 좋은 해결 방법이다.
    - nameSpace를 만들 땐, initializer가 없는 `enum`을 사용해 만드는 것이 좋다.
    - initializer가 없기 때문에 인스턴스화 할 수 없고, 의도한 그대로의 nameSpace 역할을 하게 된다.
    - autoLayout을 잡을 때, `constant`로 들어가는 값도 변수/상수로 포장해주는 것이 좋다.

- Human error를 최소화 할 수 있는 코드를 작성해야 한다.
    ```swift
    // 1번
    struct Person {
        var age: Int
    }

    // 2번
    struct Person {
        var age: Age
    }

    struct Age {
        let number: UInt
        
        init?(age: UInt) {
            guard age >= 0 && age <= 130 else { return nil }
            self.number = age
        }
    }
    ```
    - 사람 나이는 0 ~ 150 사이에 존재한다.
    - 1번의 코드에서 `age` 속성은 Int 타입이다.
        - 음수 및 터무니 없는 1000 과 같은 숫자가 들어갈 수 있다.

    - 2번의 코드에는 Age 타입을 따로 생성했다.
        - UInt로 음수를 1차적으로 막고, 2차적으로 0 ~ 150 내 숫자가 들어왔을 경우 초기화가 가능하도록 코드를 구현했다. 
        - 휴먼 에러를 최소화 한 코드 구현이라 할 수 있다.


